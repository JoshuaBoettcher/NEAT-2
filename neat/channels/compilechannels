#!/usr/bin/env python3
import os, glob, sys, inspect, shutil, subprocess, argparse

"""
Default behaviour (without options): compile neuron
with --NEST: compile NEST only
with --NEURON: compile NEURON only
with --NEST --NEURON: compile both NEST and NEURON
"""
parser = argparse.ArgumentParser()
parser.add_argument('--NEURON', dest='neuron', action=argparse.BooleanOptionalAction,
                    default=argparse.SUPPRESS, help='compile channel for neuron simulator')
parser.add_argument('--NEST', dest='nest', action=argparse.BooleanOptionalAction,
                    default=False, help='compile channel for neuron simulator')
# parse the arguments, behaviour for --NEURON depends on whether --NEST was present
args = parser.parse_args()
if (not args.nest) and ('neuron' not in vars(args)):
    args.neuron = True
elif args.nest and ('neuron' not in vars(args)):
    args.neuron = False
# set compile flags
compile_nest = args.nest
compile_neuron = args.neuron


def loadNEATCorrectPath():
    """
    Loads neat from a custom paths list where the current working directory
    only occurs as the final path, so that neat is first loaded from the install
    path and only from the current path if we are working in development mode.

    Required to run `compilechannels default` from package root directory after
    installation via `setup.py`
    """
    # get new paths list without the current working directory
    current_path = os.path.realpath(os.getcwd())
    paths = [path for path in sys.path if os.path.realpath(path) != current_path]
    paths += [current_path]

    # load module with importlib according to
    # https://stackoverflow.com/questions/35288021/what-is-the-equivalent-of-imp-find-module-in-importlib
    # and to
    # https://import-sig.python.narkive.com/JW8eIKSg/how-best-to-replace-imp-load-module
    import importlib
    neatspec = importlib.machinery.PathFinder().find_spec("neat", paths)
    neat = neatspec.loader.load_module()
    neatspec.loader.exec_module(neat)

    return neat

neat = loadNEATCorrectPath()
from neat import IonChannel

path_neat = neat.__path__[0]
path_for_mod_files = os.path.join(path_neat, 'tools/simtools/neuron/mech/')
path_for_neuron_compilation = os.path.join(path_neat, 'tools/simtools/neuron/')
path_for_nestml = os.path.join(path_neat, 'tools/simtools/nest/')
path_for_nestml_compilation = os.path.join(path_neat, 'tools/simtools/nest/tmp/')


def resetDefaultMech():
    """
    Create the "mech/" directory in a clean state with only the default
    mechanisms and channels
    """
    path_default_mech = os.path.join(path_neat, 'tools/simtools/neuron/mech_storage/')

    # recreate the "mech/" directory in a clean state
    if os.path.exists(path_for_mod_files):
        shutil.rmtree(path_for_mod_files)

    # copy default mechanisms
    shutil.copytree(path_default_mech, path_for_mod_files)

if sys.argv[1] == 'default':
    if compile_neuron: resetDefaultMech()
    path_for_channels = os.path.join(path_neat, 'channels/channelcollection/')
    nestml_name = 'default'
else:
    if compile_neuron: resetDefaultMech()
    path_for_channels = sys.argv[1]
    nestml_name = os.path.basename(os.path.normpath(path_for_channels))

print('--- writing channels from \n' + path_for_channels + '\nto \n' + path_for_mod_files)


def allBaseClasses(cls):
    """
    Return list get all base classes from a given class
    """
    return [cls.__base__] + allBaseClasses(cls.__base__) if cls is not None else []


if compile_neuron:
    if not os.path.exists(path_for_mod_files):
            os.makedirs(path_for_mod_files)

    sys.path.insert(0, path_for_channels)
    for channel_module in glob.glob(os.path.join(path_for_channels, '*.py')):
        # import channel modules
        # convert names from glob to something susceptible to python import
        channel_module = os.path.split(channel_module)[1]
        channel_module = channel_module.replace('.py', '')
        print('Reading channels from:', channel_module)
        exec('import ' + channel_module + ' as chans')

        for name, obj in inspect.getmembers(chans):
            # if an object is a class and inheriting from IonChannel, write its mod-file
            if inspect.isclass(obj) and IonChannel in allBaseClasses(obj):
                chan = obj()
                print(' - write .mod file for:', chan.__class__.__name__)
                chan.writeModFile(path_for_mod_files)

    # copy the mod-files within the source directory to the compile directory
    for mod_file in glob.glob(os.path.join(path_for_channels, '*.mod')):
        shutil.copy2(mod_file, path_for_mod_files)

    # change to directory where 'mech/' folder is located and compile the mechanisms
    os.chdir(path_for_neuron_compilation)
    if os.path.exists("x86_64/"):  # delete old compiled files if exist
        shutil.rmtree("x86_64/")
    subprocess.call(["nrnivmodl", "mech/"])  # compile all mod files


if compile_nest:
    from ..tools.simtools.nest import resources_nestml

    blocks = resources_nestml.blocks_default_syns

    sys.path.insert(0, path_for_channels)
    for channel_module in glob.glob(os.path.join(path_for_channels, '*.py')):
        # import channel modules
        # convert names from glob to something susceptible to python import
        channel_module = os.path.split(channel_module)[1]
        channel_module = channel_module.replace('.py', '')
        print('Reading channels from:', channel_module)
        exec('import ' + channel_module + ' as chans')

        for name, obj in inspect.getmembers(chans):
            # if an object is a class and inheriting from IonChannel, write its mod-file
            if inspect.isclass(obj) and IonChannel in allBaseClasses(obj):
                chan = obj()
                print(' - write .nestml blocks for:', chan.__class__.__name__)
                blocks_ = chan.writeNestmlBlocks()
                del chan

                for block, blockstr in blocks_.items():
                    blocks[block] += blockstr

    # write the nestml file
    nestml_file_path = resources_nestml.writeNestmlBlocks(blocks, path_for_nestml, nestml_name)

    from pynestml.frontend.pynestml_frontend import to_nest, install_nest
    import nest
    nest_path = nest.ll_api.sli_func("statusdict/prefix ::")

    if not os.path.exists(path_for_nestml_compilation):
        os.makedirs(path_for_nestml_compilation)

    to_nest(input_path=nestml_file_path,
            target_path=path_for_nestml_compilation,
            module_name="neatmodule_" + nestml_name,
            logging_level="ERROR")
    install_nest(path_for_nestml_compliation, nest_path)
